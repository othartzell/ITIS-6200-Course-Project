# Owen Hartzell ohartzel@charlotte.edu

# ITIS 6200 Course Project: Implementing AES-CBC Mode encryption from scratch

'''
REFERENCES
    General Research
    - Basic implementation of AES encryption with padding in python: https://www.askpython.com/python/examples/implementing-aes-with-padding
    - PKCS7 padding in python: https://stackoverflow.com/questions/43199123/encrypting-with-aes-256-and-pkcs7-padding
    - XOR operator in python: https://docs.python.org/3/reference/expressions.html
    - NIST Advanced Encryption Standard (AES) Publication: https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.197-upd1.pdf
'''

# === Imports ===
import hashlib

# === Constants ===

# 16 byte blocks for AES
block_size = 16
# 32 byte key for encryption
key_size = 32
# 16 bytes of salt to add to user inputted password
salt_size = 16

# === AES-CBC Mode helper functions ===

'''
Function to pad data using PKCS7
    - Input: data from user inputted file to encrypt
    - Calculates how many bytes of padding are needed
    - Returns: Padded data
'''
def pad(data):
    # Using block size and modulo operator to calculate how many bytes are need
    print(f"\n=== Padding ===")
    print(f"Original data length is {len(data)} bytes")
    padding_length = block_size - (len(data) % block_size)
    # Generating padding
    print(f"{padding_length} bytes of data are needed")
    padding = bytes([padding_length] * padding_length)
    padded_data = data + padding

    print(f"Padding complete, total length after padding is {len(padded_data)} bytes")
    return padded_data

'''
Function to unpad data
    - Takes in the padded data generated by the pad data function
    - Removes padding and returns the unpadded data
'''
def unpad(data):
    # Checking if data is valid
    if not data:
        raise ValueError("Data must not be empty")
    
    # Using the last byte present in data to calculate how many padding bytes exist
    print(f"\n=== Unpadding ===")
    print(f"Padded data length is {len(data)} bytes")
    padding_length = data[-1]
    print(f"{padding_length} bytes of padding found")

    # Checking that the padding is valid
    print("Validating padding length")
    if padding_length > block_size or padding_length == 0:
        raise ValueError("Padding length is invalid")
    
    # Validating that padding bytes are ordered as expected
    print("Validating padding bytes")
    for i in range(1, padding_length + 1):
        if data[-1] != padding_length:
            raise ValueError("Padding bytes are invalid")
        
    unpadded_data = data[:-padding_length]
        
    # Returning the unpadded data
    print(f"Unpadding complete, total length after unpadding is {len(unpadded_data)} bytes")
    return unpadded_data

'''
Function to generate a key and IV for encryption
    - Takes in the password entered by the user and salt added to the password
    - Derives a 32 byte key and 16 byte IV from the password and salt using sha256
    - Returns the generated key and IV to be used in CBC
'''
def generate_parameters(password, salt):
    print(f"\n=== Generating Key and IV ===")
    # Calculating the total bytes needed for the key and block
    total_bytes = key_size + block_size
    # Converting user entered password to a byte string
    password_bytes = password.encode('utf-8')
    
    print("Deriving a key and IV for encryption")
    # Deriving key and IV using sha256 and 100000 iterations
    derived_parameters = hashlib.pbkdf2_hmac(
        'sha256',
        password_bytes,
        salt,
        100000,
        dklen = total_bytes
    )

    # Splitting the derived parameters into key and IV
    key = derived_parameters[:key_size]
    iv = derived_parameters[key_size:]

    # Returning key and iv
    print("Key and IV successfully created")
    return key, iv

'''
Function to XOR two byte strings
    - Takes in two byte strings
    - Performs the XOR operation using these byte strings to add entropy for CBC
    - Returns the resulting byte string after XORing
'''
def xor(b1, b2):
    print("\n=== XOR Helper Function ===")
    print("XOR operation performed on two byte strings")
    return bytes(a ^ b for a, b in zip(b1, b2))

# === AES-CBC Mode encryption functions ===

'''
To do: Implement a function to encrypt a block of data
    - Takes in a block of plaintext and the key generated for the encryption
    - Performs encryption on the block
    - Returns the ciphertext of the block
'''

'''
To do: Implement a function to decrypt a block of data
    - Takes in a block of ciphertext and the key used for encryption
    - Performs decryption on the block
    - Returns the plaintext of the block
'''

'''
To do: Implement a function to encrypt the full file inputted by the user
    - Takes in the plaintext of the file specified by the user, the key, and IV
    - Pads the plaintext file and splits it into blocks
    - Loops through the blocks and encrypts each block
    - Returns the ciphertext
'''

'''
To do: Implement a function to decrypt the full ciphertext generated by the encrypt function
    - Takes in the ciphertext generated, the key, and the IV
    - Splits the ciphertext into blocks
    - Loops through the blocks to decrypt each block
    - Unpads plaintext after decryption
    - Returns the plaintext
'''

# === Simple GUI to demonstrate encrypting and decrypting files ===
'''
To do: Make a simple GUI
    - User can select a file locally on their machine to encrypt or decrypt
    - User can input a password for encryption or decryption
    - Provides feedback to the user for success/failure of encryption/decryption
'''